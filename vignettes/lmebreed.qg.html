<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Giovanny Covarrubias-Pazaran" />

<meta name="date" content="2024-10-16" />

<title>Quantitative genetics using the lme4breeding package</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Quantitative genetics using the
lme4breeding package</h1>
<h4 class="author">Giovanny Covarrubias-Pazaran</h4>
<h4 class="date">2024-10-16</h4>



<p>lme4breeding is nice wrapper of the lme4 package that enables the use
of especialized plant and animal breeding models that include
relationship matrices among individuals (e.g., genomic relationship
matrices) and complex covariance structures between factors (e.g.,
factor analytic structures). It uses all the lme4 machinery for linear
and non-linear models, for different response distributions opening a
world of possibilities.</p>
<p>The vignettes aim to provide several examples in how to use the
lme4breeding package under different scenarios. We will spend the rest
of the space providing examples for:</p>
<p><strong>SECTION 1: Basic topics in quantitative genetics
</strong></p>
<ol style="list-style-type: decimal">
<li>Heritability (<span class="math inline">\(h^2\)</span>)
calculation</li>
<li>Specifying heterogeneous variances in mixed models</li>
<li>Half and full diallel designs (using the overlay)</li>
<li>Genomic selection (predicting mendelian sampling)
<ul>
<li>GBLUP</li>
<li>rrBLUP</li>
</ul></li>
<li>Indirect genetic effects</li>
<li>GCA models and single cross prediction (hybrid prediction)</li>
<li>Spatial modeling (using the 2-dimensional splines)</li>
<li>Multivariate genetic models and genetic correlations</li>
</ol>
<p><strong>SECTION 2: Special topics in quantitative
genetics</strong></p>
<ol style="list-style-type: decimal">
<li>Partitioned model</li>
<li>UDU’ decomposition</li>
<li>Mating designs</li>
<li>GWAS by GBLUP</li>
</ol>
<div id="section-1-basic-topics-in-quantitative-genetics" class="section level2">
<h2>SECTION 1: Basic topics in quantitative genetics</h2>
<div id="marker-and-non-marker-based-heritability-calculation" class="section level3">
<h3>1) Marker and non-marker based heritability calculation</h3>
<p>Heritability is one of the most popular parameters among the breeding
and genetics communities because of the insight it provides in the
inheritance of the trait and potential selection response. Heritability
is usually estimated as narrow sense (<span class="math inline">\(h^2\)</span>; only additive variance in the
numerator <span class="math inline">\(\sigma^2_A\)</span>), and broad
sense (<span class="math inline">\(H^2\)</span>; all genetic variance in
the numerator <span class="math inline">\(\sigma^2_G\)</span>).</p>
<p>In a classical breeding experiment with no molecular markers, special
designs are performed to estimate and dissect the additive (<span class="math inline">\(\sigma^2_A\)</span>) and non-additive (e.g.,
dominance <span class="math inline">\(\sigma^2_D\)</span>, and epistatic
<span class="math inline">\(\sigma^2_E\)</span>) variance along with
environmental variability. Designs such as generation analysis, North
Carolina designs are used to dissect <span class="math inline">\(\sigma^2_A\)</span> and <span class="math inline">\(\sigma^2_D\)</span> to estimate the narrow sense
heritability (<span class="math inline">\(h^2\)</span>) using only <span class="math inline">\(\sigma^2_A\)</span> in the numerator. When no
special design is available we can still disect the genetic variance
(<span class="math inline">\(\sigma^2_G\)</span>) and estimate the broad
sense heritability. In this first example we will show the broad sense
estimation which doesn’t use covariance matrices for the genotypic
effect (e.g., genomic-additive relationship matrices).</p>
<p>The following dataset has 41 potato lines evaluated in 5 locations
across 3 years in an RCBD design. We show how to fit the model and
extract the variance components to calculate the <span class="math inline">\(h^2\)</span>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">data</span>(DT_example)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>DT <span class="ot">&lt;-</span> DT_example</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>A <span class="ot">&lt;-</span> A_example</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>ans1 <span class="ot">&lt;-</span> <span class="fu">lmebreed</span>(Yield<span class="sc">~</span> (<span class="dv">1</span><span class="sc">|</span>Name) <span class="sc">+</span> (<span class="dv">1</span><span class="sc">|</span>Env) <span class="sc">+</span> </span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>                   (<span class="dv">1</span><span class="sc">|</span>Env<span class="sc">:</span>Name) <span class="sc">+</span> (<span class="dv">1</span><span class="sc">|</span>Env<span class="sc">:</span>Block),</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>             <span class="at">verbose =</span> <span class="cn">FALSE</span>, <span class="at">data=</span>DT)</span></code></pre></div>
<pre><code>## boundary (singular) fit: see help(&#39;isSingular&#39;)</code></pre>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>vc <span class="ot">&lt;-</span> <span class="fu">VarCorr</span>(ans1); <span class="fu">print</span>(vc,<span class="at">comp=</span><span class="fu">c</span>(<span class="st">&quot;Variance&quot;</span>))</span></code></pre></div>
<pre><code>##  Groups    Name        Variance
##  Env:Name  (Intercept)  5.1528 
##  Name      (Intercept)  3.7184 
##  Env:Block (Intercept)  0.0000 
##  Env       (Intercept) 12.0084 
##  Residual               4.3661</code></pre>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>ve <span class="ot">&lt;-</span> <span class="fu">attr</span>(<span class="fu">VarCorr</span>(ans1), <span class="st">&quot;sc&quot;</span>)<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>n.env <span class="ot">&lt;-</span> <span class="fu">length</span>(<span class="fu">levels</span>(DT<span class="sc">$</span>Env))</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>H2<span class="ot">=</span>vc<span class="sc">$</span>Name <span class="sc">/</span> ( vc<span class="sc">$</span>Name <span class="sc">+</span> (vc<span class="sc">$</span><span class="st">`</span><span class="at">Env:Name</span><span class="st">`</span><span class="sc">/</span>n.env) <span class="sc">+</span> (ve<span class="sc">/</span>(n.env<span class="sc">*</span><span class="dv">2</span>)) )</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>H2</span></code></pre></div>
<pre><code>##             (Intercept)
## (Intercept)   0.6032732
## attr(,&quot;stddev&quot;)
## (Intercept) 
##    1.928306 
## attr(,&quot;correlation&quot;)
##             (Intercept)
## (Intercept)           1</code></pre>
<p>That is an estimate of broad-sense heritability.</p>
<p>Recently with markers becoming cheaper, thousand of markers can be
run in the breeding materials. When markers are available, a special
design is not neccesary to dissect the additive genetic variance. The
availability of the additive, dominance and epistatic relationship
matrices allow us to estimate <span class="math inline">\(\sigma^2_A\)</span>, <span class="math inline">\(\sigma^2_D\)</span> and <span class="math inline">\(\sigma^2_I\)</span>, although given that A, D and
E are not orthogonal the interpretation of models that fit more than the
A matrix at the same time becomes cumbersome.</p>
<p>Assume you have a population (even unreplicated) in the field but in
addition we have genetic markers. Now we can fit the model and estimate
the genomic heritability that explains a portion of the additive genetic
variance (with high marker density <span class="math inline">\(\sigma^2_A\)</span> = <span class="math inline">\(\sigma^2_{markers}\)</span>)</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">data</span>(DT_cpdata)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>DT <span class="ot">&lt;-</span> DT_cpdata</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>GT <span class="ot">&lt;-</span> GT_cpdata</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>MP <span class="ot">&lt;-</span> MP_cpdata</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="do">#### create the variance-covariance matrix</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>A <span class="ot">&lt;-</span> <span class="fu">A.mat</span>(GT) <span class="co"># additive relationship matrix</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>A <span class="ot">&lt;-</span> A <span class="sc">+</span> <span class="fu">diag</span>(<span class="fl">1e-4</span>, <span class="fu">ncol</span>(A), <span class="fu">ncol</span>(A))</span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="do">#### look at the data and fit the model</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a><span class="fu">head</span>(DT)</span></code></pre></div>
<pre><code>##        id Row Col Year      color  Yield FruitAver Firmness Rowf Colf
## P003 P003   3   1 2014 0.10075269 154.67     41.93  588.917    3    1
## P004 P004   4   1 2014 0.13891940 186.77     58.79  640.031    4    1
## P005 P005   5   1 2014 0.08681502  80.21     48.16  671.523    5    1
## P006 P006   6   1 2014 0.13408561 202.96     48.24  687.172    6    1
## P007 P007   7   1 2014 0.13519278 174.74     45.83  601.322    7    1
## P008 P008   8   1 2014 0.17406685 194.16     44.63  656.379    8    1</code></pre>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>mix1 <span class="ot">&lt;-</span> <span class="fu">lmebreed</span>(Yield<span class="sc">~</span> (<span class="dv">1</span><span class="sc">|</span>id) <span class="sc">+</span> (<span class="dv">1</span><span class="sc">|</span>Rowf) <span class="sc">+</span> (<span class="dv">1</span><span class="sc">|</span>Colf),</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>                 <span class="at">relmat=</span><span class="fu">list</span>(<span class="at">id=</span>A),</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>                 <span class="at">control =</span> <span class="fu">lmerControl</span>(</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>                   <span class="at">check.nobs.vs.nlev =</span> <span class="st">&quot;ignore&quot;</span>,</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>                   <span class="at">check.nobs.vs.rankZ =</span> <span class="st">&quot;ignore&quot;</span>,</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>                   <span class="at">check.nobs.vs.nRE=</span><span class="st">&quot;ignore&quot;</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>                 ),<span class="at">verbose =</span> <span class="cn">FALSE</span>,</span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>                 <span class="at">data=</span>DT)</span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a>vc <span class="ot">&lt;-</span> <span class="fu">VarCorr</span>(mix1); <span class="fu">print</span>(vc,<span class="at">comp=</span><span class="fu">c</span>(<span class="st">&quot;Variance&quot;</span>))</span></code></pre></div>
<pre><code>##  Groups   Name        Variance
##  id       (Intercept)  806.26 
##  Colf     (Intercept)  198.43 
##  Rowf     (Intercept)  848.63 
##  Residual             2992.29</code></pre>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>ve <span class="ot">&lt;-</span> <span class="fu">attr</span>(<span class="fu">VarCorr</span>(mix1), <span class="st">&quot;sc&quot;</span>)<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>h2<span class="ot">=</span> vc<span class="sc">$</span>id <span class="sc">/</span> ( vc<span class="sc">$</span>id <span class="sc">+</span> ve )</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="fu">as.numeric</span>(h2)</span></code></pre></div>
<pre><code>## [1] 0.212254</code></pre>
<p>In this example we showed how to estimate the additive (<span class="math inline">\(\sigma^2_A\)</span>) variance components based on
markers and estimate narrow-sense heritability (<span class="math inline">\(h^2\)</span>). Notice that we used the
<code>relmat</code> argument which indicates that the random effect
inside the parenthesis (i.e. <code>id</code>) has a covariance matrix
(A), that will be specified as the Cholesky of the relationship matrix.
Please DO NOT provide the inverse to the Cholesky, but rather the
original covariance matrix.</p>
</div>
<div id="specifying-heterogeneous-variances-in-univariate-models" class="section level3">
<h3>2) Specifying heterogeneous variances in univariate models</h3>
<p>Very often in multi-environment trials, the assumption that genetic
variance is the same across locations may be too naive. Because of that,
specifying a general genetic component and a location-specific genetic
variance is the way to go.</p>
<p>We estimate variance components for specific environments.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">data</span>(DT_example)</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>DT <span class="ot">&lt;-</span> DT_example</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>A <span class="ot">&lt;-</span> A_example</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="fu">head</span>(DT)</span></code></pre></div>
<pre><code>##                   Name     Env Loc Year     Block Yield    Weight
## 33  Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.1     4 -1.904711
## 65          CO02024-9W CA.2013  CA 2013 CA.2013.1     5 -1.446958
## 66  Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.2     5 -1.516271
## 67            MSL007-B CA.2011  CA 2011 CA.2011.2     5 -1.435510
## 68           MSR169-8Y CA.2013  CA 2013 CA.2013.1     5 -1.469051
## 103         AC05153-1W CA.2013  CA 2013 CA.2013.1     6 -1.307167</code></pre>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="do">## Compound simmetry (CS) + Diagonal (DIAG) model</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>Z <span class="ot">&lt;-</span> <span class="fu">with</span>(DT, <span class="fu">smm</span>(Env))</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>csdiagFormula <span class="ot">&lt;-</span> <span class="fu">paste0</span>( <span class="st">&quot;Yield ~ Env + (&quot;</span>, <span class="fu">paste</span>(<span class="fu">colnames</span>(Z), <span class="at">collapse =</span> <span class="st">&quot;+&quot;</span>), <span class="st">&quot;|| Name)&quot;</span>)</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(Z)){DT[,<span class="fu">colnames</span>(Z)[i]] <span class="ot">&lt;-</span> Z[,i]}</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>ansCSDG <span class="ot">&lt;-</span> <span class="fu">lmebreed</span>(<span class="fu">as.formula</span>(csdiagFormula),</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>                    <span class="at">relmat =</span> <span class="fu">list</span>(<span class="at">Name =</span> A ),</span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>                    <span class="at">verbose =</span> <span class="cn">FALSE</span>, <span class="at">data=</span>DT)</span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a>vc <span class="ot">&lt;-</span> <span class="fu">VarCorr</span>(ansCSDG); <span class="fu">print</span>(vc,<span class="at">comp=</span><span class="fu">c</span>(<span class="st">&quot;Variance&quot;</span>))</span></code></pre></div>
<pre><code>##  Groups   Name        Variance
##  Name     (Intercept)  2.9637 
##  Name.1   CA.2011     10.4264 
##  Name.2   CA.2012      2.6589 
##  Name.3   CA.2013      5.7017 
##  Residual              4.3976</code></pre>
<p>In the previous example we showed how the left side of the formulae
to specify the covariance structure and the effect on the right side
<code>(covStructure | effect)</code> in the <code>lmebreed()</code>
solver. By specifying <code>( CA.2011+CA.2012+CA.2013 || Name)</code> we
declare a covariance structure for Name between environments. The
<code>||</code> indicates that we do not want to fit covariance between
these environments This is considered a CS + DIAG (compound symmetry +
diagonal) model.</p>
</div>
<div id="half-and-full-diallel-designs-use-of-the-overlay" class="section level3">
<h3>3) Half and full diallel designs (use of the overlay)</h3>
<p>When breeders are looking for the best single-cross combinations,
diallel designs have been by far the most used design in crops like
maize. There are 4 types of diallel designs depending on whether
reciprocal and self-crosses (omission of parents) are performed (full
diallel with parents n^2; full diallel without parents n(n-1); half
diallel with parents 1/2 * n(n+1); half diallel without parents 1/2 *
n(n-1) ). In this example we will show a full diallel design (reciprocal
crosses are performed) and half diallel designs (only one of the
directions is performed).</p>
<p>In the first data set we show a full diallel among 40 lines from 2
heterotic groups, 20 in each. Therefore 400 possible hybrids are
possible. We have pehnotypic data for 100 of them across 4 locations. We
use the data available to fit a model of the form:</p>
<p><br></p>
<p><span class="math inline">\(y = X\beta + Zu_1 + Zu_2 + Zu_S +
\epsilon\)</span></p>
<p><br></p>
<p>We estimate variance components for <span class="math inline">\(GCA_1\)</span>, <span class="math inline">\(GCA_2\)</span> and <span class="math inline">\(SCA\)</span> and use them to estimate
heritability. Additionally BLUPs for GCA and SCA effects can be used to
predict crosses.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="fu">data</span>(DT_cornhybrids)</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>DT <span class="ot">&lt;-</span> DT_cornhybrids</span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>DTi <span class="ot">&lt;-</span> DTi_cornhybrids</span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a>GT <span class="ot">&lt;-</span> GT_cornhybrids</span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a>modFD <span class="ot">&lt;-</span> <span class="fu">lmebreed</span>(Yield<span class="sc">~</span>Location <span class="sc">+</span> (<span class="dv">1</span><span class="sc">|</span>GCA1)<span class="sc">+</span>(<span class="dv">1</span><span class="sc">|</span>GCA2)<span class="sc">+</span>(<span class="dv">1</span><span class="sc">|</span>SCA),</span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a>              <span class="at">verbose =</span> <span class="cn">FALSE</span>,<span class="at">data=</span>DT)</span></code></pre></div>
<pre><code>## boundary (singular) fit: see help(&#39;isSingular&#39;)</code></pre>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>vc <span class="ot">&lt;-</span> <span class="fu">VarCorr</span>(modFD); <span class="fu">print</span>(vc,<span class="at">comp=</span><span class="fu">c</span>(<span class="st">&quot;Variance&quot;</span>))</span></code></pre></div>
<pre><code>##  Groups   Name        Variance
##  SCA      (Intercept) 187.6620
##  GCA2     (Intercept)   7.2901
##  GCA1     (Intercept)   0.0000
##  Residual             221.1425</code></pre>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>Vgca <span class="ot">&lt;-</span> vc<span class="sc">$</span>GCA1 <span class="sc">+</span> vc<span class="sc">$</span>GCA2</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>Vsca <span class="ot">&lt;-</span> vc<span class="sc">$</span>SCA</span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>Ve <span class="ot">&lt;-</span> <span class="fu">attr</span>(vc, <span class="st">&quot;sc&quot;</span>)<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a>Va <span class="ot">=</span> <span class="dv">4</span><span class="sc">*</span>Vgca</span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>Vd <span class="ot">=</span> <span class="dv">4</span><span class="sc">*</span>Vsca</span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a>Vg <span class="ot">&lt;-</span> Va <span class="sc">+</span> Vd</span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a>(H2 <span class="ot">&lt;-</span> Vg <span class="sc">/</span> (Vg <span class="sc">+</span> (Ve)) )</span></code></pre></div>
<pre><code>##             (Intercept)
## (Intercept)   0.7790676
## attr(,&quot;stddev&quot;)
## (Intercept) 
##           0 
## attr(,&quot;correlation&quot;)
##             (Intercept)
## (Intercept)           1</code></pre>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>(h2 <span class="ot">&lt;-</span> Va <span class="sc">/</span> (Vg <span class="sc">+</span> (Ve)) )</span></code></pre></div>
<pre><code>##             (Intercept)
## (Intercept)  0.02913284
## attr(,&quot;stddev&quot;)
## (Intercept) 
##           0 
## attr(,&quot;correlation&quot;)
##             (Intercept)
## (Intercept)           1</code></pre>
<p>Don’t worry too much about the <code>h2</code> value, the data was
simulated to be mainly dominance variance, therefore the <code>Va</code>
was simulated extremely small leading to such value of narrow sense
<code>h2</code>.</p>
<p>In the second data set we show a small half diallel with 7 parents
crossed in one direction. There are n(n-1)/2 possible crosses; 7(6)/2 =
21 unique crosses. Parents appear as males or females indistictly. Each
with two replications in a CRD. For a half diallel design a single GCA
variance component for both males and females can be estimated and an
SCA as well (<span class="math inline">\(\sigma^2_GCA\)</span> and <span class="math inline">\(\sigma^2_SCA\)</span> respectively), and BLUPs for
GCA and SCA of the parents can be extracted. We will show how to do so
using the <code>overlay()</code> function. The specific model here
is:</p>
<p><span class="math inline">\(y = X\beta + Zu_g + Zu_s +
\epsilon\)</span></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;DT_halfdiallel&quot;</span>)</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>DT <span class="ot">&lt;-</span> DT_halfdiallel</span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a><span class="fu">head</span>(DT)</span></code></pre></div>
<pre><code>##   rep geno male female     sugar
## 1   1   12    1      2 13.950509
## 2   2   12    1      2  9.756918
## 3   1   13    1      3 13.906355
## 4   2   13    1      3  9.119455
## 5   1   14    1      4  5.174483
## 6   2   14    1      4  8.452221</code></pre>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>DT<span class="sc">$</span>femalef <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(DT<span class="sc">$</span>female)</span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>DT<span class="sc">$</span>malef <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(DT<span class="sc">$</span>male)</span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a>DT<span class="sc">$</span>genof <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(DT<span class="sc">$</span>geno)</span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a><span class="co"># overlay matrix to be added to the addmat argument</span></span>
<span id="cb27-5"><a href="#cb27-5" tabindex="-1"></a>Z <span class="ot">&lt;-</span> <span class="fu">with</span>(DT, <span class="fu">overlay</span>(femalef,malef) )</span>
<span id="cb27-6"><a href="#cb27-6" tabindex="-1"></a><span class="co"># create inital values for incidence matrix but irrelevant</span></span>
<span id="cb27-7"><a href="#cb27-7" tabindex="-1"></a><span class="co"># since these will be replaced by admat argument</span></span>
<span id="cb27-8"><a href="#cb27-8" tabindex="-1"></a>fema <span class="ot">&lt;-</span> (<span class="fu">rep</span>(<span class="fu">colnames</span>(Z), <span class="fu">nrow</span>(DT)))[<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(DT)]</span>
<span id="cb27-9"><a href="#cb27-9" tabindex="-1"></a><span class="do">#### model using overlay without relationship matrix</span></span>
<span id="cb27-10"><a href="#cb27-10" tabindex="-1"></a>modh <span class="ot">&lt;-</span> <span class="fu">lmebreed</span>(sugar <span class="sc">~</span> (<span class="dv">1</span><span class="sc">|</span>genof) <span class="sc">+</span> (<span class="dv">1</span><span class="sc">|</span>fema),</span>
<span id="cb27-11"><a href="#cb27-11" tabindex="-1"></a>                 <span class="at">addmat =</span> <span class="fu">list</span>(<span class="at">fema=</span>Z),</span>
<span id="cb27-12"><a href="#cb27-12" tabindex="-1"></a>             <span class="at">verbose =</span> <span class="cn">FALSE</span>, <span class="at">data=</span>DT)</span>
<span id="cb27-13"><a href="#cb27-13" tabindex="-1"></a>vc <span class="ot">&lt;-</span> <span class="fu">VarCorr</span>(modh); <span class="fu">print</span>(vc,<span class="at">comp=</span><span class="fu">c</span>(<span class="st">&quot;Variance&quot;</span>))</span></code></pre></div>
<pre><code>##  Groups   Name        Variance
##  genof    (Intercept) 1.8160  
##  fema     (Intercept) 5.5088  
##  Residual             3.1173</code></pre>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a>ve <span class="ot">&lt;-</span> <span class="fu">attr</span>(vc, <span class="st">&quot;sc&quot;</span>)<span class="sc">^</span><span class="dv">2</span>;ve</span></code></pre></div>
<pre><code>## [1] 3.117349</code></pre>
<p>Notice how the <code>overlay()</code> argument makes the overlap of
incidence matrices possible making sure that male and female are joint
into a single random effect.</p>
</div>
<div id="genomic-selection-predicting-mendelian-sampling" class="section level3">
<h3>4) Genomic selection: predicting mendelian sampling</h3>
<p>In this section we will use wheat data from CIMMYT to show how
genomic selection is performed. This is the case of prediction of
specific individuals within a population. It basically uses a similar
model of the form:</p>
<p><br></p>
<p><span class="math inline">\(y = X\beta + Zu + \epsilon\)</span></p>
<p><br></p>
<p>and takes advantage of the variance covariance matrix for the
genotype effect known as the additive relationship matrix (A) and
calculated using the <code>A.mat</code> function to establish
connections among all individuals and predict the BLUPs for individuals
that were not measured. The prediction accuracy depends on several
factors such as the heritability (<span class="math inline">\(h^2\)</span>), training population used (TP), size
of TP, etc.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="co"># data(DT_wheat)</span></span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a><span class="co"># DT &lt;- DT_wheat</span></span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a><span class="co"># GT &lt;- GT_wheat[,1:200]</span></span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a><span class="co"># colnames(DT) &lt;- paste0(&quot;X&quot;,1:ncol(DT))</span></span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a><span class="co"># DT &lt;- as.data.frame(DT);DT$line &lt;- as.factor(rownames(DT))</span></span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a><span class="co"># # select environment 1</span></span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a><span class="co"># rownames(GT) &lt;- rownames(DT)</span></span>
<span id="cb31-8"><a href="#cb31-8" tabindex="-1"></a><span class="co"># K &lt;- A.mat(GT) # additive relationship matrix</span></span>
<span id="cb31-9"><a href="#cb31-9" tabindex="-1"></a><span class="co"># colnames(K) &lt;- rownames(K) &lt;- rownames(DT)</span></span>
<span id="cb31-10"><a href="#cb31-10" tabindex="-1"></a><span class="co"># # GBLUP pedigree-based approach</span></span>
<span id="cb31-11"><a href="#cb31-11" tabindex="-1"></a><span class="co"># set.seed(12345)</span></span>
<span id="cb31-12"><a href="#cb31-12" tabindex="-1"></a><span class="co"># y.trn &lt;- DT</span></span>
<span id="cb31-13"><a href="#cb31-13" tabindex="-1"></a><span class="co"># vv &lt;- sample(rownames(DT),round(nrow(DT)/5))</span></span>
<span id="cb31-14"><a href="#cb31-14" tabindex="-1"></a><span class="co"># y.trn[vv,&quot;X1&quot;] &lt;- NA</span></span>
<span id="cb31-15"><a href="#cb31-15" tabindex="-1"></a><span class="co"># head(y.trn)</span></span>
<span id="cb31-16"><a href="#cb31-16" tabindex="-1"></a><span class="co"># ## GBLUP</span></span>
<span id="cb31-17"><a href="#cb31-17" tabindex="-1"></a><span class="co"># K &lt;- K + diag(1e-4, ncol(K), ncol(K) )</span></span>
<span id="cb31-18"><a href="#cb31-18" tabindex="-1"></a><span class="co"># ans &lt;- lmebreed(X1 ~ (1|line), </span></span>
<span id="cb31-19"><a href="#cb31-19" tabindex="-1"></a><span class="co">#                 relmat = list(line=K),</span></span>
<span id="cb31-20"><a href="#cb31-20" tabindex="-1"></a><span class="co">#                 control = lmerControl(</span></span>
<span id="cb31-21"><a href="#cb31-21" tabindex="-1"></a><span class="co">#                   check.nobs.vs.nlev = &quot;ignore&quot;,</span></span>
<span id="cb31-22"><a href="#cb31-22" tabindex="-1"></a><span class="co">#                   check.nobs.vs.rankZ = &quot;ignore&quot;,</span></span>
<span id="cb31-23"><a href="#cb31-23" tabindex="-1"></a><span class="co">#                   check.nobs.vs.nRE=&quot;ignore&quot;</span></span>
<span id="cb31-24"><a href="#cb31-24" tabindex="-1"></a><span class="co">#                 ), verbose = FALSE,</span></span>
<span id="cb31-25"><a href="#cb31-25" tabindex="-1"></a><span class="co">#                 data=y.trn)</span></span>
<span id="cb31-26"><a href="#cb31-26" tabindex="-1"></a><span class="co"># vc &lt;- VarCorr(ans); print(vc,comp=c(&quot;Variance&quot;))</span></span>
<span id="cb31-27"><a href="#cb31-27" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb31-28"><a href="#cb31-28" tabindex="-1"></a><span class="co"># # take a extended dataset and fit a dummy model </span></span>
<span id="cb31-29"><a href="#cb31-29" tabindex="-1"></a><span class="co"># # just to get required matrices</span></span>
<span id="cb31-30"><a href="#cb31-30" tabindex="-1"></a><span class="co"># y.tst &lt;- y.trn; y.tst$X1 &lt;- imputev(y.tst$X1)</span></span>
<span id="cb31-31"><a href="#cb31-31" tabindex="-1"></a><span class="co"># ans2 &lt;- update(ans, </span></span>
<span id="cb31-32"><a href="#cb31-32" tabindex="-1"></a><span class="co">#                start = getME(ans, &quot;theta&quot;),</span></span>
<span id="cb31-33"><a href="#cb31-33" tabindex="-1"></a><span class="co">#                data = y.tst,</span></span>
<span id="cb31-34"><a href="#cb31-34" tabindex="-1"></a><span class="co">#                control = lmerControl(check.nobs.vs.nlev = &quot;ignore&quot;,</span></span>
<span id="cb31-35"><a href="#cb31-35" tabindex="-1"></a><span class="co">#                                      check.nobs.vs.rankZ = &quot;ignore&quot;,</span></span>
<span id="cb31-36"><a href="#cb31-36" tabindex="-1"></a><span class="co">#                                      check.nobs.vs.nRE=&quot;ignore&quot;,</span></span>
<span id="cb31-37"><a href="#cb31-37" tabindex="-1"></a><span class="co">#                                      optCtrl = list(maxeval= 1),</span></span>
<span id="cb31-38"><a href="#cb31-38" tabindex="-1"></a><span class="co">#                                      calc.derivs = FALSE))</span></span>
<span id="cb31-39"><a href="#cb31-39" tabindex="-1"></a><span class="co"># # compute predictive ability</span></span>
<span id="cb31-40"><a href="#cb31-40" tabindex="-1"></a><span class="co"># cor(ranef(ans2)$line[vv,],DT[vv,&quot;X1&quot;], use=&quot;complete&quot;)</span></span>
<span id="cb31-41"><a href="#cb31-41" tabindex="-1"></a><span class="co"># # # other approach</span></span>
<span id="cb31-42"><a href="#cb31-42" tabindex="-1"></a><span class="co"># # mme &lt;- getMME(ans2, vc=vc, recordsToKeep = which(!is.na(y.trn$X1)))</span></span>
<span id="cb31-43"><a href="#cb31-43" tabindex="-1"></a><span class="co"># # cor(mme$bu[vv,],DT[vv,&quot;X1&quot;], use=&quot;complete&quot;)</span></span>
<span id="cb31-44"><a href="#cb31-44" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb31-45"><a href="#cb31-45" tabindex="-1"></a><span class="co"># ## rrBLUP</span></span>
<span id="cb31-46"><a href="#cb31-46" tabindex="-1"></a><span class="co"># M &lt;- tcrossprod(GT)</span></span>
<span id="cb31-47"><a href="#cb31-47" tabindex="-1"></a><span class="co"># xx &lt;- with(y.trn, redmm(x=line, M=M, nPC=100, returnLam = TRUE))</span></span>
<span id="cb31-48"><a href="#cb31-48" tabindex="-1"></a><span class="co"># custom &lt;- (rep(colnames(Z), nrow(DT)))[1:nrow(DT)]</span></span>
<span id="cb31-49"><a href="#cb31-49" tabindex="-1"></a><span class="co"># ansRRBLUP &lt;- lmebreed(X1 ~ (1|custom), verbose = FALSE,</span></span>
<span id="cb31-50"><a href="#cb31-50" tabindex="-1"></a><span class="co">#                       addmat = list(custom=Z),</span></span>
<span id="cb31-51"><a href="#cb31-51" tabindex="-1"></a><span class="co">#                       data=y.trn)</span></span>
<span id="cb31-52"><a href="#cb31-52" tabindex="-1"></a><span class="co"># re &lt;- ranef(ansRRBLUP)$custom</span></span>
<span id="cb31-53"><a href="#cb31-53" tabindex="-1"></a><span class="co"># u = tcrossprod(xx$Lam, t(as.matrix( re[colnames(xx$Lam),] ) ))</span></span>
<span id="cb31-54"><a href="#cb31-54" tabindex="-1"></a><span class="co"># cor(u[vv,],DT[vv,&quot;X1&quot;], use=&quot;complete&quot;)</span></span></code></pre></div>
</div>
<div id="indirect-genetic-effects" class="section level3">
<h3>5) Indirect genetic effects</h3>
<p>General variance structures can be used to fit indirect genetic
effects. Here, we use an example dataset to show how we can fit the
variance and covariance components between two or more different random
effects. We now fit the indirect genetic effects model with covariance
between DGE and IGE. On top of that we can include a relationship matrix
for the two random effects that are being forced to co-vary</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="co"># data(DT_ige)</span></span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a><span class="co"># DT &lt;- DT_ige</span></span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a><span class="co"># A_ige &lt;- A_ige + diag(1e-4, ncol(A_ige), ncol(A_ige) )</span></span>
<span id="cb32-4"><a href="#cb32-4" tabindex="-1"></a><span class="co"># # Define 2 dummy variables to make a fake covariance</span></span>
<span id="cb32-5"><a href="#cb32-5" tabindex="-1"></a><span class="co"># # for two different random effects</span></span>
<span id="cb32-6"><a href="#cb32-6" tabindex="-1"></a><span class="co"># DT$fn &lt;- DT$nn &lt;- 1</span></span>
<span id="cb32-7"><a href="#cb32-7" tabindex="-1"></a><span class="co"># # Create the incidence matrix for the first random effect</span></span>
<span id="cb32-8"><a href="#cb32-8" tabindex="-1"></a><span class="co"># Zf &lt;- Matrix::sparse.model.matrix( ~ focal-1, data=DT )</span></span>
<span id="cb32-9"><a href="#cb32-9" tabindex="-1"></a><span class="co"># colnames(Zf) &lt;- gsub(&quot;focal&quot;,&quot;&quot;, colnames(Zf))</span></span>
<span id="cb32-10"><a href="#cb32-10" tabindex="-1"></a><span class="co"># # Create the incidence matrix for the second random effect</span></span>
<span id="cb32-11"><a href="#cb32-11" tabindex="-1"></a><span class="co"># Zn &lt;- Matrix::sparse.model.matrix( ~ neighbour-1, data=DT )</span></span>
<span id="cb32-12"><a href="#cb32-12" tabindex="-1"></a><span class="co"># colnames(Zn) &lt;- gsub(&quot;neighbour&quot;,&quot;&quot;, colnames(Zn))</span></span>
<span id="cb32-13"><a href="#cb32-13" tabindex="-1"></a><span class="co"># # Make inital values for incidence matrix but irrelevant</span></span>
<span id="cb32-14"><a href="#cb32-14" tabindex="-1"></a><span class="co"># # since these will be replaced by the addmat argument</span></span>
<span id="cb32-15"><a href="#cb32-15" tabindex="-1"></a><span class="co"># both &lt;- (rep(colnames(Zf), nrow(DT)))[1:nrow(DT)]</span></span>
<span id="cb32-16"><a href="#cb32-16" tabindex="-1"></a><span class="co"># # Fit the model</span></span>
<span id="cb32-17"><a href="#cb32-17" tabindex="-1"></a><span class="co"># modIGE &lt;- lmebreed(trait ~ block + (0+fn+nn|both),</span></span>
<span id="cb32-18"><a href="#cb32-18" tabindex="-1"></a><span class="co">#                    addmat = list(both=list(Zf,Zn)),</span></span>
<span id="cb32-19"><a href="#cb32-19" tabindex="-1"></a><span class="co">#                    relmat = list(both=A_ige),</span></span>
<span id="cb32-20"><a href="#cb32-20" tabindex="-1"></a><span class="co">#                    verbose = FALSE, data = DT)</span></span>
<span id="cb32-21"><a href="#cb32-21" tabindex="-1"></a><span class="co"># vc &lt;- VarCorr(modIGE); print(vc,comp=c(&quot;Variance&quot;))</span></span>
<span id="cb32-22"><a href="#cb32-22" tabindex="-1"></a><span class="co"># blups &lt;- ranef(modIGE)</span></span>
<span id="cb32-23"><a href="#cb32-23" tabindex="-1"></a><span class="co"># pairs(blups$both)</span></span>
<span id="cb32-24"><a href="#cb32-24" tabindex="-1"></a><span class="co"># cov2cor(vc$both)</span></span></code></pre></div>
</div>
<div id="genomic-selection-single-cross-prediction" class="section level3">
<h3>6) Genomic selection: single cross prediction</h3>
<p>When doing prediction of single cross performance the phenotype can
be dissected in three main components, the general combining abilities
(GCA) and specific combining abilities (SCA). This can be expressed with
the same model analyzed in the diallel experiment mentioned before:</p>
<p><br></p>
<p><span class="math inline">\(y = X\beta + Zu_1 + Zu_2 + Zu_S +
\epsilon\)</span></p>
<p><br></p>
<p>with:</p>
<p><br></p>
<p><span class="math inline">\(u_1\)</span> ~ N(0, <span class="math inline">\(K_1\)</span><span class="math inline">\(\sigma^2_u1\)</span>)</p>
<p><span class="math inline">\(u_2\)</span> ~ N(0, <span class="math inline">\(K_2\)</span><span class="math inline">\(\sigma^2_u2\)</span>)</p>
<p><span class="math inline">\(u_s\)</span> ~ N(0, <span class="math inline">\(K_3\)</span><span class="math inline">\(\sigma^2_us\)</span>)</p>
<p><br></p>
<p>And we can specify the K matrices. The main difference between this
model and the full and half diallel designs is the fact that this model
will include variance covariance structures in each of the three random
effects (GCA1, GCA2 and SCA) to be able to predict the crosses that have
not ocurred yet. We will use the data published by Technow et al. (2015)
to show how to do prediction of single crosses.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a><span class="co"># data(DT_technow)</span></span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a><span class="co"># DT &lt;- DT_technow</span></span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a><span class="co"># Md &lt;- (Md_technow*2) - 1</span></span>
<span id="cb33-4"><a href="#cb33-4" tabindex="-1"></a><span class="co"># Mf &lt;- (Mf_technow*2) - 1</span></span>
<span id="cb33-5"><a href="#cb33-5" tabindex="-1"></a><span class="co"># Ad &lt;- A.mat(Md)</span></span>
<span id="cb33-6"><a href="#cb33-6" tabindex="-1"></a><span class="co"># Af &lt;- A.mat(Mf)</span></span>
<span id="cb33-7"><a href="#cb33-7" tabindex="-1"></a><span class="co"># Ad &lt;- Ad + diag(1e-4, ncol(Ad), ncol(Ad))</span></span>
<span id="cb33-8"><a href="#cb33-8" tabindex="-1"></a><span class="co"># Af &lt;- Af + diag(1e-4, ncol(Af), ncol(Af))</span></span>
<span id="cb33-9"><a href="#cb33-9" tabindex="-1"></a><span class="co"># # simulate some missing hybrids to predict</span></span>
<span id="cb33-10"><a href="#cb33-10" tabindex="-1"></a><span class="co"># y.trn &lt;- DT</span></span>
<span id="cb33-11"><a href="#cb33-11" tabindex="-1"></a><span class="co"># vv1 &lt;- which(!is.na(DT$GY))</span></span>
<span id="cb33-12"><a href="#cb33-12" tabindex="-1"></a><span class="co"># vv2 &lt;- sample(DT[vv1,&quot;hy&quot;], 100)</span></span>
<span id="cb33-13"><a href="#cb33-13" tabindex="-1"></a><span class="co"># y.trn[which(y.trn$hy %in% vv2),&quot;GY&quot;] &lt;- NA</span></span>
<span id="cb33-14"><a href="#cb33-14" tabindex="-1"></a><span class="co"># ans2 &lt;- lmebreed(GY ~ (1|dent) + (1|flint),</span></span>
<span id="cb33-15"><a href="#cb33-15" tabindex="-1"></a><span class="co">#                  relmat = list(dent=Ad,</span></span>
<span id="cb33-16"><a href="#cb33-16" tabindex="-1"></a><span class="co">#                                flint=Af),</span></span>
<span id="cb33-17"><a href="#cb33-17" tabindex="-1"></a><span class="co">#                  verbose = FALSE, data=y.trn)</span></span>
<span id="cb33-18"><a href="#cb33-18" tabindex="-1"></a><span class="co"># vc &lt;- VarCorr(ans2); print(vc,comp=c(&quot;Variance&quot;))</span></span>
<span id="cb33-19"><a href="#cb33-19" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb33-20"><a href="#cb33-20" tabindex="-1"></a><span class="co"># # take a extended dataset and fit a dummy model </span></span>
<span id="cb33-21"><a href="#cb33-21" tabindex="-1"></a><span class="co"># # just to get required matrices</span></span>
<span id="cb33-22"><a href="#cb33-22" tabindex="-1"></a><span class="co"># y.tst &lt;- y.trn; y.tst$GY &lt;- imputev(y.tst$GY)</span></span>
<span id="cb33-23"><a href="#cb33-23" tabindex="-1"></a><span class="co"># ans2p &lt;- update(ans2, </span></span>
<span id="cb33-24"><a href="#cb33-24" tabindex="-1"></a><span class="co">#                 start = getME(ans2, &quot;theta&quot;),</span></span>
<span id="cb33-25"><a href="#cb33-25" tabindex="-1"></a><span class="co">#                 data = y.tst,</span></span>
<span id="cb33-26"><a href="#cb33-26" tabindex="-1"></a><span class="co">#                 control = lmerControl(check.nobs.vs.nlev = &quot;ignore&quot;,</span></span>
<span id="cb33-27"><a href="#cb33-27" tabindex="-1"></a><span class="co">#                                       check.nobs.vs.rankZ = &quot;ignore&quot;,</span></span>
<span id="cb33-28"><a href="#cb33-28" tabindex="-1"></a><span class="co">#                                       check.nobs.vs.nRE=&quot;ignore&quot;,</span></span>
<span id="cb33-29"><a href="#cb33-29" tabindex="-1"></a><span class="co">#                                       optCtrl = list(maxeval= 1),</span></span>
<span id="cb33-30"><a href="#cb33-30" tabindex="-1"></a><span class="co">#                                       calc.derivs = FALSE))</span></span>
<span id="cb33-31"><a href="#cb33-31" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb33-32"><a href="#cb33-32" tabindex="-1"></a><span class="co"># re &lt;- ranef(ans2p)</span></span>
<span id="cb33-33"><a href="#cb33-33" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb33-34"><a href="#cb33-34" tabindex="-1"></a><span class="co"># Pdent &lt;- as.matrix(re$dent[,1,drop=FALSE]) %*% Matrix(1, ncol=nrow(re$flint), nrow=1)</span></span>
<span id="cb33-35"><a href="#cb33-35" tabindex="-1"></a><span class="co"># Pflint &lt;- as.matrix(re$flint[,1,drop=FALSE]) %*% Matrix(1, ncol=nrow(re$dent), nrow=1)</span></span>
<span id="cb33-36"><a href="#cb33-36" tabindex="-1"></a><span class="co"># P &lt;- Pdent + t(Pflint); colnames(P) &lt;- rownames(re$flint)</span></span>
<span id="cb33-37"><a href="#cb33-37" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb33-38"><a href="#cb33-38" tabindex="-1"></a><span class="co"># preds &lt;- real &lt;- numeric()</span></span>
<span id="cb33-39"><a href="#cb33-39" tabindex="-1"></a><span class="co"># for(iHyb in vv2){ </span></span>
<span id="cb33-40"><a href="#cb33-40" tabindex="-1"></a><span class="co">#   parents &lt;- strsplit(iHyb,&quot;:&quot;)[[1]]</span></span>
<span id="cb33-41"><a href="#cb33-41" tabindex="-1"></a><span class="co">#   preds[iHyb] &lt;- P[which(rownames(P) %in% parents),which(colnames(P) %in% parents)]</span></span>
<span id="cb33-42"><a href="#cb33-42" tabindex="-1"></a><span class="co">#   real[iHyb] &lt;- DT[which(DT$hy == iHyb),&quot;GY&quot;]</span></span>
<span id="cb33-43"><a href="#cb33-43" tabindex="-1"></a><span class="co"># }</span></span>
<span id="cb33-44"><a href="#cb33-44" tabindex="-1"></a><span class="co"># plot(preds, real)</span></span>
<span id="cb33-45"><a href="#cb33-45" tabindex="-1"></a><span class="co"># cor(preds, real)</span></span></code></pre></div>
<p>In the previous model we only used the GCA effects (GCA1 and GCA2)
for practicity, altough it’s been shown that the SCA effect doesn’t
actually help that much in increasing prediction accuracy, but does
increase a lot the computation intensity required since the variance
covariance matrix for SCA is the kronecker product of the variance
covariance matrices for the GCA effects, resulting in a 10578 x 10578
matrix that increases in a very intensive manner the computation
required.</p>
<p>A model without covariance structures would show that the SCA
variance component is insignificant compared to the GCA effects. This is
why including the third random effect doesn’t increase the prediction
accuracy.</p>
</div>
<div id="spatial-modeling-using-the-2-dimensional-spline" class="section level3">
<h3>8) Spatial modeling: using the 2-dimensional spline</h3>
<p>We will use the CPdata to show the use of 2-dimensional splines for
accomodating spatial effects in field experiments. In early generation
variety trials the availability of seed is low, which makes the use of
unreplicated designs a neccesity more than anything else. Experimental
designs such as augmented designs and partially-replicated (p-rep)
designs are becoming ever more common these days.</p>
<p>In order to do a good job modeling the spatial trends happening in
the field, special covariance structures have been proposed to
accomodate such spatial trends (i.e. autoregressive residuals; ar1).
Unfortunately, some of these covariance structures make the modeling
rather unstable. More recently, other research groups have proposed the
use of 2-dimensional splines to overcome such issues and have a more
robust modeling of the spatial terms (Lee et al. 2013; Rodríguez-Álvarez
et al. 2018).</p>
<p>In this example we assume an unreplicated population where row and
range information is available which allows us to fit a 2 dimensional
spline model.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a><span class="fu">data</span>(DT_cpdata)</span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a>DT <span class="ot">&lt;-</span> DT_cpdata</span>
<span id="cb34-3"><a href="#cb34-3" tabindex="-1"></a><span class="co"># add the units column</span></span>
<span id="cb34-4"><a href="#cb34-4" tabindex="-1"></a>DT<span class="sc">$</span>units <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(DT))</span>
<span id="cb34-5"><a href="#cb34-5" tabindex="-1"></a><span class="co"># get spatial incidence matrix</span></span>
<span id="cb34-6"><a href="#cb34-6" tabindex="-1"></a>Zs <span class="ot">&lt;-</span> <span class="fu">with</span>(DT, <span class="fu">tps</span>(Row, Col))<span class="sc">$</span>All</span>
<span id="cb34-7"><a href="#cb34-7" tabindex="-1"></a><span class="fu">rownames</span>(Zs) <span class="ot">&lt;-</span> DT<span class="sc">$</span>units</span>
<span id="cb34-8"><a href="#cb34-8" tabindex="-1"></a><span class="co"># reduce the matrix to its PCs</span></span>
<span id="cb34-9"><a href="#cb34-9" tabindex="-1"></a>Z <span class="ot">=</span> <span class="fu">with</span>(DT, <span class="fu">redmm</span>(<span class="at">x=</span>units, <span class="at">M=</span>Zs, <span class="at">nPC=</span><span class="dv">100</span>))</span>
<span id="cb34-10"><a href="#cb34-10" tabindex="-1"></a><span class="co"># create dummy variable</span></span>
<span id="cb34-11"><a href="#cb34-11" tabindex="-1"></a>spatial <span class="ot">&lt;-</span> (<span class="fu">rep</span>(<span class="fu">colnames</span>(Z), <span class="fu">nrow</span>(DT)))[<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(DT)]</span>
<span id="cb34-12"><a href="#cb34-12" tabindex="-1"></a><span class="co"># fit model</span></span>
<span id="cb34-13"><a href="#cb34-13" tabindex="-1"></a>mix1 <span class="ot">&lt;-</span> <span class="fu">lmebreed</span>(Yield<span class="sc">~</span> (<span class="dv">1</span><span class="sc">|</span>Rowf) <span class="sc">+</span> (<span class="dv">1</span><span class="sc">|</span>Colf) <span class="sc">+</span> (<span class="dv">1</span><span class="sc">|</span>spatial),</span>
<span id="cb34-14"><a href="#cb34-14" tabindex="-1"></a>                 <span class="at">addmat =</span><span class="fu">list</span>(<span class="at">spatial=</span>Z),</span>
<span id="cb34-15"><a href="#cb34-15" tabindex="-1"></a>                 <span class="at">control =</span> <span class="fu">lmerControl</span>(</span>
<span id="cb34-16"><a href="#cb34-16" tabindex="-1"></a>                   <span class="at">check.nobs.vs.nlev =</span> <span class="st">&quot;ignore&quot;</span>,</span>
<span id="cb34-17"><a href="#cb34-17" tabindex="-1"></a>                   <span class="at">check.nobs.vs.rankZ =</span> <span class="st">&quot;ignore&quot;</span>,</span>
<span id="cb34-18"><a href="#cb34-18" tabindex="-1"></a>                   <span class="at">check.nobs.vs.nRE=</span><span class="st">&quot;ignore&quot;</span></span>
<span id="cb34-19"><a href="#cb34-19" tabindex="-1"></a>                 ), <span class="at">verbose =</span> <span class="cn">FALSE</span>,</span>
<span id="cb34-20"><a href="#cb34-20" tabindex="-1"></a>                 <span class="at">data=</span>DT)</span>
<span id="cb34-21"><a href="#cb34-21" tabindex="-1"></a>vc <span class="ot">&lt;-</span> <span class="fu">VarCorr</span>(mix1); <span class="fu">print</span>(vc,<span class="at">comp=</span><span class="fu">c</span>(<span class="st">&quot;Variance&quot;</span>))</span></code></pre></div>
<pre><code>##  Groups   Name        Variance
##  spatial  (Intercept)  320.61 
##  Colf     (Intercept)  158.29 
##  Rowf     (Intercept)  823.48 
##  Residual             3564.70</code></pre>
<p>Notice that the job is done by the <code>spl2Da()</code> function
that takes the <code>Row</code> and <code>Col</code> information to fit
a spatial kernel.</p>
</div>
<div id="multivariate-genetic-models-and-genetic-correlations" class="section level3">
<h3>9) Multivariate genetic models and genetic correlations</h3>
<p>Sometimes is important to estimate genetic variance-covariance among
traits–multi-reponse models are very useful for such a task. Let see an
example with 2 traits (<code>color</code>, <code>Yield</code>) and a
single random effect (genotype; <code>id</code>) although multiple
effects can be modeled as well. We need to use a variance covariance
structure for the random effect to be able to obtain the genetic
covariance among traits.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a><span class="co"># data(DT_cpdata)</span></span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a><span class="co"># DT &lt;- DT_cpdata</span></span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a><span class="co"># GT &lt;- GT_cpdata</span></span>
<span id="cb36-4"><a href="#cb36-4" tabindex="-1"></a><span class="co"># MP &lt;- MP_cpdata</span></span>
<span id="cb36-5"><a href="#cb36-5" tabindex="-1"></a><span class="co"># #### create the variance-covariance matrix</span></span>
<span id="cb36-6"><a href="#cb36-6" tabindex="-1"></a><span class="co"># A &lt;- A.mat(GT) # additive relationship matrix</span></span>
<span id="cb36-7"><a href="#cb36-7" tabindex="-1"></a><span class="co"># A &lt;- A + diag(1e-4, ncol(A), ncol(A))</span></span>
<span id="cb36-8"><a href="#cb36-8" tabindex="-1"></a><span class="co"># #### look at the data and fit the model</span></span>
<span id="cb36-9"><a href="#cb36-9" tabindex="-1"></a><span class="co"># head(DT)</span></span>
<span id="cb36-10"><a href="#cb36-10" tabindex="-1"></a><span class="co"># DT2 &lt;- stackTrait(data=DT, traits = c(&quot;Yield&quot;,&quot;color&quot;))</span></span>
<span id="cb36-11"><a href="#cb36-11" tabindex="-1"></a><span class="co"># head(DT2$long)</span></span>
<span id="cb36-12"><a href="#cb36-12" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb36-13"><a href="#cb36-13" tabindex="-1"></a><span class="co"># mix1 &lt;- lmebreed(valueS~ (0+trait|id),</span></span>
<span id="cb36-14"><a href="#cb36-14" tabindex="-1"></a><span class="co">#                  relmat=list(id=A),</span></span>
<span id="cb36-15"><a href="#cb36-15" tabindex="-1"></a><span class="co">#                  control = lmerControl(</span></span>
<span id="cb36-16"><a href="#cb36-16" tabindex="-1"></a><span class="co">#                    check.nobs.vs.nlev = &quot;ignore&quot;,</span></span>
<span id="cb36-17"><a href="#cb36-17" tabindex="-1"></a><span class="co">#                    check.nobs.vs.rankZ = &quot;ignore&quot;,</span></span>
<span id="cb36-18"><a href="#cb36-18" tabindex="-1"></a><span class="co">#                    check.nobs.vs.nRE=&quot;ignore&quot;</span></span>
<span id="cb36-19"><a href="#cb36-19" tabindex="-1"></a><span class="co">#                  ), verbose = FALSE,</span></span>
<span id="cb36-20"><a href="#cb36-20" tabindex="-1"></a><span class="co">#                  data=DT2$long)</span></span>
<span id="cb36-21"><a href="#cb36-21" tabindex="-1"></a><span class="co"># vc &lt;- VarCorr(mix1); print(vc,comp=c(&quot;Variance&quot;))</span></span></code></pre></div>
<p>Now you can extract the BLUPs using <code>ranef(ans.m)</code>. Also,
genetic correlations and heritabilities can be calculated easily.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a><span class="co"># cov2cor(vc$id)</span></span></code></pre></div>
</div>
</div>
<div id="section-2-special-topics-in-quantitative-genetics" class="section level2">
<h2>SECTION 2: Special topics in Quantitative genetics</h2>
<div id="partitioned-model" class="section level3">
<h3>1) Partitioned model</h3>
<p>The partitioned model was popularized by () to show that marker
effects can be obtained by fitting a GBLUP model to reduce the
computational burden and then recover them by creating some special
matrices MM’ for GBLUP and M’(M’M)- to recover marker effects. Here we
show a very easy example using the DT_cpdata:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a><span class="co"># data(&quot;DT_cpdata&quot;)</span></span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a><span class="co"># DT &lt;- as.data.frame(DT_cpdata) </span></span>
<span id="cb38-3"><a href="#cb38-3" tabindex="-1"></a><span class="co"># M &lt;- GT_cpdata</span></span>
<span id="cb38-4"><a href="#cb38-4" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb38-5"><a href="#cb38-5" tabindex="-1"></a><span class="co"># ################</span></span>
<span id="cb38-6"><a href="#cb38-6" tabindex="-1"></a><span class="co"># # PARTITIONED GBLUP MODEL</span></span>
<span id="cb38-7"><a href="#cb38-7" tabindex="-1"></a><span class="co"># ################</span></span>
<span id="cb38-8"><a href="#cb38-8" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb38-9"><a href="#cb38-9" tabindex="-1"></a><span class="co"># MMT &lt;-tcrossprod(M) ## MM&#39; = additive relationship matrix </span></span>
<span id="cb38-10"><a href="#cb38-10" tabindex="-1"></a><span class="co"># MMTinv&lt;-solve(MMT) ## inverse</span></span>
<span id="cb38-11"><a href="#cb38-11" tabindex="-1"></a><span class="co"># MTMMTinv&lt;-t(M)%*%MMTinv # M&#39; %*% (M&#39;M)-</span></span>
<span id="cb38-12"><a href="#cb38-12" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb38-13"><a href="#cb38-13" tabindex="-1"></a><span class="co"># mix.part &lt;- lmebreed(color ~ (1|id),</span></span>
<span id="cb38-14"><a href="#cb38-14" tabindex="-1"></a><span class="co">#                      relmat = list(id=MMT),</span></span>
<span id="cb38-15"><a href="#cb38-15" tabindex="-1"></a><span class="co">#                      control = lmerControl(</span></span>
<span id="cb38-16"><a href="#cb38-16" tabindex="-1"></a><span class="co">#                        check.nobs.vs.nlev = &quot;ignore&quot;,</span></span>
<span id="cb38-17"><a href="#cb38-17" tabindex="-1"></a><span class="co">#                        check.nobs.vs.rankZ = &quot;ignore&quot;,</span></span>
<span id="cb38-18"><a href="#cb38-18" tabindex="-1"></a><span class="co">#                        check.nobs.vs.nRE=&quot;ignore&quot;</span></span>
<span id="cb38-19"><a href="#cb38-19" tabindex="-1"></a><span class="co">#                      ), verbose = FALSE,</span></span>
<span id="cb38-20"><a href="#cb38-20" tabindex="-1"></a><span class="co">#                      data=DT)</span></span>
<span id="cb38-21"><a href="#cb38-21" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb38-22"><a href="#cb38-22" tabindex="-1"></a><span class="co"># #convert BLUPs to marker effects me=M&#39;(M&#39;M)- u</span></span>
<span id="cb38-23"><a href="#cb38-23" tabindex="-1"></a><span class="co"># re &lt;- ranef(mix.part)$id</span></span>
<span id="cb38-24"><a href="#cb38-24" tabindex="-1"></a><span class="co"># me.part&lt;-MTMMTinv[,rownames(re)]%*%matrix(re[,1],ncol=1)</span></span>
<span id="cb38-25"><a href="#cb38-25" tabindex="-1"></a><span class="co"># plot(me.part)</span></span></code></pre></div>
<p>As can be seen, these two models are equivalent with the exception
that the partitioned model is more computationally efficient.</p>
</div>
<div id="udu-decomposition" class="section level3">
<h3>2) UDU’ decomposition</h3>
<p>Lee and Van der Warf (2015) proposed a decomposition of the
relationship matrix A=UDU’ together with a transformation of the
response and fixed effects Uy = Ux + UZ + e, to fit a model where the
phenotypic variance matrix V is a diagonal because the relationship
matrix is the diagonal matrix D from the decomposition that can be
inverted easily and make multitrait models more feasible.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb39-2"><a href="#cb39-2" tabindex="-1"></a><span class="co"># data(&quot;DT_wheat&quot;)</span></span>
<span id="cb39-3"><a href="#cb39-3" tabindex="-1"></a><span class="co"># rownames(GT_wheat) &lt;- rownames(DT_wheat)</span></span>
<span id="cb39-4"><a href="#cb39-4" tabindex="-1"></a><span class="co"># G &lt;- A.mat(GT_wheat)</span></span>
<span id="cb39-5"><a href="#cb39-5" tabindex="-1"></a><span class="co"># Y &lt;- data.frame(DT_wheat)</span></span>
<span id="cb39-6"><a href="#cb39-6" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb39-7"><a href="#cb39-7" tabindex="-1"></a><span class="co"># # make the decomposition</span></span>
<span id="cb39-8"><a href="#cb39-8" tabindex="-1"></a><span class="co"># UD&lt;-eigen(G) # get the decomposition: G = UDU&#39;</span></span>
<span id="cb39-9"><a href="#cb39-9" tabindex="-1"></a><span class="co"># U&lt;-UD$vectors</span></span>
<span id="cb39-10"><a href="#cb39-10" tabindex="-1"></a><span class="co"># D&lt;-diag(UD$values)# This will be our new &#39;relationship-matrix&#39;</span></span>
<span id="cb39-11"><a href="#cb39-11" tabindex="-1"></a><span class="co"># rownames(D) &lt;- colnames(D) &lt;- rownames(G)</span></span>
<span id="cb39-12"><a href="#cb39-12" tabindex="-1"></a><span class="co"># X&lt;-model.matrix(~1, data=Y) # here: only one fixed effect (intercept)</span></span>
<span id="cb39-13"><a href="#cb39-13" tabindex="-1"></a><span class="co"># UX&lt;-t(U)%*%X # premultiply X and y by U&#39;</span></span>
<span id="cb39-14"><a href="#cb39-14" tabindex="-1"></a><span class="co"># UY &lt;- t(U) %*% as.matrix(Y) # multivariate</span></span>
<span id="cb39-15"><a href="#cb39-15" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb39-16"><a href="#cb39-16" tabindex="-1"></a><span class="co"># # dataset for decomposed model</span></span>
<span id="cb39-17"><a href="#cb39-17" tabindex="-1"></a><span class="co"># DTd&lt;-data.frame(id = rownames(G) ,UY, UX =UX[,1])</span></span>
<span id="cb39-18"><a href="#cb39-18" tabindex="-1"></a><span class="co"># DTd$id&lt;-as.character(DTd$id)</span></span>
<span id="cb39-19"><a href="#cb39-19" tabindex="-1"></a><span class="co"># head(DTd)</span></span>
<span id="cb39-20"><a href="#cb39-20" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb39-21"><a href="#cb39-21" tabindex="-1"></a><span class="co"># modeld &lt;- lmebreed(X1~ UX + (1|id),</span></span>
<span id="cb39-22"><a href="#cb39-22" tabindex="-1"></a><span class="co">#                  relmat=list(id=D),</span></span>
<span id="cb39-23"><a href="#cb39-23" tabindex="-1"></a><span class="co">#                  control = lmerControl(</span></span>
<span id="cb39-24"><a href="#cb39-24" tabindex="-1"></a><span class="co">#                    check.nobs.vs.nlev = &quot;ignore&quot;,</span></span>
<span id="cb39-25"><a href="#cb39-25" tabindex="-1"></a><span class="co">#                    check.nobs.vs.rankZ = &quot;ignore&quot;,</span></span>
<span id="cb39-26"><a href="#cb39-26" tabindex="-1"></a><span class="co">#                    check.nobs.vs.nRE=&quot;ignore&quot;</span></span>
<span id="cb39-27"><a href="#cb39-27" tabindex="-1"></a><span class="co">#                  ), verbose = FALSE,</span></span>
<span id="cb39-28"><a href="#cb39-28" tabindex="-1"></a><span class="co">#                  data=DTd)</span></span>
<span id="cb39-29"><a href="#cb39-29" tabindex="-1"></a><span class="co"># vc &lt;- VarCorr(modeld); print(vc,comp=c(&quot;Variance&quot;))</span></span>
<span id="cb39-30"><a href="#cb39-30" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb39-31"><a href="#cb39-31" tabindex="-1"></a><span class="co"># # dataset for normal model</span></span>
<span id="cb39-32"><a href="#cb39-32" tabindex="-1"></a><span class="co"># DTn&lt;-data.frame(id = rownames(G) , DT_wheat)</span></span>
<span id="cb39-33"><a href="#cb39-33" tabindex="-1"></a><span class="co"># DTn$id&lt;-as.character(DTn$id)</span></span>
<span id="cb39-34"><a href="#cb39-34" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb39-35"><a href="#cb39-35" tabindex="-1"></a><span class="co"># modeln &lt;- lmebreed(X1~ (1|id),</span></span>
<span id="cb39-36"><a href="#cb39-36" tabindex="-1"></a><span class="co">#                    relmat=list(id=G),</span></span>
<span id="cb39-37"><a href="#cb39-37" tabindex="-1"></a><span class="co">#                    control = lmerControl(</span></span>
<span id="cb39-38"><a href="#cb39-38" tabindex="-1"></a><span class="co">#                      check.nobs.vs.nlev = &quot;ignore&quot;,</span></span>
<span id="cb39-39"><a href="#cb39-39" tabindex="-1"></a><span class="co">#                      check.nobs.vs.rankZ = &quot;ignore&quot;,</span></span>
<span id="cb39-40"><a href="#cb39-40" tabindex="-1"></a><span class="co">#                      check.nobs.vs.nRE=&quot;ignore&quot;</span></span>
<span id="cb39-41"><a href="#cb39-41" tabindex="-1"></a><span class="co">#                    ), verbose = FALSE,</span></span>
<span id="cb39-42"><a href="#cb39-42" tabindex="-1"></a><span class="co">#                    data=DTn)</span></span>
<span id="cb39-43"><a href="#cb39-43" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb39-44"><a href="#cb39-44" tabindex="-1"></a><span class="co"># ## compare regular and transformed blups</span></span>
<span id="cb39-45"><a href="#cb39-45" tabindex="-1"></a><span class="co"># red &lt;- ranef(modeld)$id</span></span>
<span id="cb39-46"><a href="#cb39-46" tabindex="-1"></a><span class="co"># ren &lt;- ranef(modeln)$id</span></span>
<span id="cb39-47"><a href="#cb39-47" tabindex="-1"></a><span class="co"># plot(x=(solve(t(U)))%*%  red[colnames(D),],</span></span>
<span id="cb39-48"><a href="#cb39-48" tabindex="-1"></a><span class="co">#      y=ren[colnames(D),], </span></span>
<span id="cb39-49"><a href="#cb39-49" tabindex="-1"></a><span class="co">#      xlab=&quot;UDU blup&quot;, ylab=&quot;blup&quot;)</span></span>
<span id="cb39-50"><a href="#cb39-50" tabindex="-1"></a><span class="co"># </span></span></code></pre></div>
<p>As can be seen, the two models are equivalent. The lme4breeding
library uses this trick directly by setting the argument
rotation=TRUE.</p>
</div>
<div id="mating-designs" class="section level3">
<h3>3) Mating designs</h3>
<p>Estimating variance components has been a topic of interest for the
breeding community for a long time. Here we show how to calculate
additive and dominance variance using the North Carolina Design I
(Nested design) and North Carolina Design II (Factorial design) using
the classical Expected Mean Squares method and the REML methods from
lme4breeding and how these two are equivalent.</p>
<div id="north-carolina-design-i-nested-design" class="section level4">
<h4>North Carolina Design I (Nested design)</h4>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a><span class="fu">data</span>(DT_expdesigns)</span>
<span id="cb40-2"><a href="#cb40-2" tabindex="-1"></a>DT <span class="ot">&lt;-</span> DT_expdesigns<span class="sc">$</span>car1</span>
<span id="cb40-3"><a href="#cb40-3" tabindex="-1"></a>DT <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(yield<span class="sc">~</span>set<span class="sc">+</span>male<span class="sc">+</span>female<span class="sc">+</span>rep, <span class="at">data=</span>DT, <span class="at">FUN =</span> mean)</span>
<span id="cb40-4"><a href="#cb40-4" tabindex="-1"></a>DT<span class="sc">$</span>setf <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(DT<span class="sc">$</span>set)</span>
<span id="cb40-5"><a href="#cb40-5" tabindex="-1"></a>DT<span class="sc">$</span>repf <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(DT<span class="sc">$</span>rep)</span>
<span id="cb40-6"><a href="#cb40-6" tabindex="-1"></a>DT<span class="sc">$</span>malef <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(DT<span class="sc">$</span>male)</span>
<span id="cb40-7"><a href="#cb40-7" tabindex="-1"></a>DT<span class="sc">$</span>femalef <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(DT<span class="sc">$</span>female)</span>
<span id="cb40-8"><a href="#cb40-8" tabindex="-1"></a><span class="co">#levelplot(yield~male*female|set, data=DT, main=&quot;NC design I&quot;)</span></span>
<span id="cb40-9"><a href="#cb40-9" tabindex="-1"></a><span class="do">##############################</span></span>
<span id="cb40-10"><a href="#cb40-10" tabindex="-1"></a><span class="do">## Expected Mean Square method</span></span>
<span id="cb40-11"><a href="#cb40-11" tabindex="-1"></a><span class="do">##############################</span></span>
<span id="cb40-12"><a href="#cb40-12" tabindex="-1"></a>mix1 <span class="ot">&lt;-</span> <span class="fu">lm</span>(yield<span class="sc">~</span> setf <span class="sc">+</span> setf<span class="sc">:</span>repf <span class="sc">+</span> femalef<span class="sc">:</span>malef<span class="sc">:</span>setf <span class="sc">+</span> malef<span class="sc">:</span>setf, <span class="at">data=</span>DT)</span>
<span id="cb40-13"><a href="#cb40-13" tabindex="-1"></a>MS <span class="ot">&lt;-</span> <span class="fu">anova</span>(mix1); MS</span></code></pre></div>
<pre><code>## Analysis of Variance Table
## 
## Response: yield
##                    Df Sum Sq Mean Sq F value   Pr(&gt;F)    
## setf                1 0.1780 0.17796  1.6646 0.226012    
## setf:repf           2 0.9965 0.49824  4.6605 0.037141 *  
## setf:malef          4 7.3904 1.84759 17.2822 0.000173 ***
## setf:femalef:malef  6 1.6083 0.26806  2.5074 0.095575 .  
## Residuals          10 1.0691 0.10691                     
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" tabindex="-1"></a>ms1 <span class="ot">&lt;-</span> MS[<span class="st">&quot;setf:malef&quot;</span>,<span class="st">&quot;Mean Sq&quot;</span>]</span>
<span id="cb42-2"><a href="#cb42-2" tabindex="-1"></a>ms2 <span class="ot">&lt;-</span> MS[<span class="st">&quot;setf:femalef:malef&quot;</span>,<span class="st">&quot;Mean Sq&quot;</span>]</span>
<span id="cb42-3"><a href="#cb42-3" tabindex="-1"></a>mse <span class="ot">&lt;-</span> MS[<span class="st">&quot;Residuals&quot;</span>,<span class="st">&quot;Mean Sq&quot;</span>]</span>
<span id="cb42-4"><a href="#cb42-4" tabindex="-1"></a>nrep<span class="ot">=</span><span class="dv">2</span></span>
<span id="cb42-5"><a href="#cb42-5" tabindex="-1"></a>nfem<span class="ot">=</span><span class="dv">2</span></span>
<span id="cb42-6"><a href="#cb42-6" tabindex="-1"></a>Vfm <span class="ot">&lt;-</span> (ms2<span class="sc">-</span>mse)<span class="sc">/</span>nrep</span>
<span id="cb42-7"><a href="#cb42-7" tabindex="-1"></a>Vm <span class="ot">&lt;-</span> (ms1<span class="sc">-</span>ms2)<span class="sc">/</span>(nrep<span class="sc">*</span>nfem)</span>
<span id="cb42-8"><a href="#cb42-8" tabindex="-1"></a></span>
<span id="cb42-9"><a href="#cb42-9" tabindex="-1"></a><span class="do">## Calculate Va and Vd</span></span>
<span id="cb42-10"><a href="#cb42-10" tabindex="-1"></a>Va<span class="ot">=</span><span class="dv">4</span><span class="sc">*</span>Vm <span class="co"># assuming no inbreeding (4/(1+F))</span></span>
<span id="cb42-11"><a href="#cb42-11" tabindex="-1"></a>Vd<span class="ot">=</span><span class="dv">4</span><span class="sc">*</span>(Vfm<span class="sc">-</span>Vm) <span class="co"># assuming no inbreeding(4/(1+F)^2)</span></span>
<span id="cb42-12"><a href="#cb42-12" tabindex="-1"></a>Vg<span class="ot">=</span><span class="fu">c</span>(Va,Vd); <span class="fu">names</span>(Vg) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;Va&quot;</span>,<span class="st">&quot;Vd&quot;</span>); Vg</span></code></pre></div>
<pre><code>##        Va        Vd 
##  1.579537 -1.257241</code></pre>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a><span class="do">##############################</span></span>
<span id="cb44-2"><a href="#cb44-2" tabindex="-1"></a><span class="do">## REML method</span></span>
<span id="cb44-3"><a href="#cb44-3" tabindex="-1"></a><span class="do">##############################</span></span>
<span id="cb44-4"><a href="#cb44-4" tabindex="-1"></a>mix2 <span class="ot">&lt;-</span> <span class="fu">lmebreed</span>(yield<span class="sc">~</span> setf <span class="sc">+</span> setf<span class="sc">:</span>repf <span class="sc">+</span></span>
<span id="cb44-5"><a href="#cb44-5" tabindex="-1"></a>                   (<span class="dv">1</span><span class="sc">|</span>femalef<span class="sc">:</span>malef<span class="sc">:</span>setf) <span class="sc">+</span> (<span class="dv">1</span><span class="sc">|</span>malef<span class="sc">:</span>setf), </span>
<span id="cb44-6"><a href="#cb44-6" tabindex="-1"></a>             <span class="at">verbose =</span> <span class="cn">FALSE</span>, <span class="at">data=</span>DT)</span>
<span id="cb44-7"><a href="#cb44-7" tabindex="-1"></a>vc <span class="ot">&lt;-</span> <span class="fu">VarCorr</span>(mix2); <span class="fu">print</span>(vc,<span class="at">comp=</span><span class="fu">c</span>(<span class="st">&quot;Variance&quot;</span>))</span></code></pre></div>
<pre><code>##  Groups             Name        Variance
##  femalef:malef:setf (Intercept) 0.080574
##  malef:setf         (Intercept) 0.394884
##  Residual                       0.106907</code></pre>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a>Vfm <span class="ot">&lt;-</span> vc<span class="sc">$</span><span class="st">`</span><span class="at">femalef:malef:setf</span><span class="st">`</span></span>
<span id="cb46-2"><a href="#cb46-2" tabindex="-1"></a>Vm <span class="ot">&lt;-</span> vc<span class="sc">$</span><span class="st">`</span><span class="at">malef:setf</span><span class="st">`</span></span>
<span id="cb46-3"><a href="#cb46-3" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" tabindex="-1"></a><span class="do">## Calculate Va and Vd</span></span>
<span id="cb46-5"><a href="#cb46-5" tabindex="-1"></a>Va<span class="ot">=</span><span class="dv">4</span><span class="sc">*</span>Vm <span class="co"># assuming no inbreeding (4/(1+F))</span></span>
<span id="cb46-6"><a href="#cb46-6" tabindex="-1"></a>Vd<span class="ot">=</span><span class="dv">4</span><span class="sc">*</span>(Vfm<span class="sc">-</span>Vm) <span class="co"># assuming no inbreeding(4/(1+F)^2)</span></span>
<span id="cb46-7"><a href="#cb46-7" tabindex="-1"></a>Vg<span class="ot">=</span><span class="fu">c</span>(Va,Vd); <span class="fu">names</span>(Vg) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;Va&quot;</span>,<span class="st">&quot;Vd&quot;</span>); Vg</span></code></pre></div>
<pre><code>##        Va        Vd 
##  1.579537 -1.257240</code></pre>
<p>As can be seen the REML method is easier than manipulating the MS and
we arrive to the same results.</p>
</div>
<div id="north-carolina-design-ii-factorial-design" class="section level4">
<h4>North Carolina Design II (Factorial design)</h4>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a>DT <span class="ot">&lt;-</span> DT_expdesigns<span class="sc">$</span>car2</span>
<span id="cb48-2"><a href="#cb48-2" tabindex="-1"></a>DT <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(yield<span class="sc">~</span>set<span class="sc">+</span>male<span class="sc">+</span>female<span class="sc">+</span>rep, <span class="at">data=</span>DT, <span class="at">FUN =</span> mean)</span>
<span id="cb48-3"><a href="#cb48-3" tabindex="-1"></a>DT<span class="sc">$</span>setf <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(DT<span class="sc">$</span>set)</span>
<span id="cb48-4"><a href="#cb48-4" tabindex="-1"></a>DT<span class="sc">$</span>repf <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(DT<span class="sc">$</span>rep)</span>
<span id="cb48-5"><a href="#cb48-5" tabindex="-1"></a>DT<span class="sc">$</span>malef <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(DT<span class="sc">$</span>male)</span>
<span id="cb48-6"><a href="#cb48-6" tabindex="-1"></a>DT<span class="sc">$</span>femalef <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(DT<span class="sc">$</span>female)</span>
<span id="cb48-7"><a href="#cb48-7" tabindex="-1"></a><span class="co">#levelplot(yield~male*female|set, data=DT, main=&quot;NC desing II&quot;)</span></span>
<span id="cb48-8"><a href="#cb48-8" tabindex="-1"></a><span class="fu">head</span>(DT)</span></code></pre></div>
<pre><code>##   set male female rep   yield setf repf malef femalef
## 1   1    1      1   1  831.03    1    1     1       1
## 2   1    2      1   1 1046.55    1    1     2       1
## 3   1    3      1   1  853.33    1    1     3       1
## 4   1    4      1   1  940.00    1    1     4       1
## 5   1    5      1   1  802.00    1    1     5       1
## 6   1    1      2   1  625.93    1    1     1       2</code></pre>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a>N<span class="ot">=</span><span class="fu">with</span>(DT,<span class="fu">table</span>(female, male, set))</span>
<span id="cb50-2"><a href="#cb50-2" tabindex="-1"></a>nmale<span class="ot">=</span><span class="fu">length</span>(<span class="fu">which</span>(N[<span class="dv">1</span>,,<span class="dv">1</span>] <span class="sc">&gt;</span> <span class="dv">0</span>))</span>
<span id="cb50-3"><a href="#cb50-3" tabindex="-1"></a>nfemale<span class="ot">=</span><span class="fu">length</span>(<span class="fu">which</span>(N[,<span class="dv">1</span>,<span class="dv">1</span>] <span class="sc">&gt;</span> <span class="dv">0</span>))</span>
<span id="cb50-4"><a href="#cb50-4" tabindex="-1"></a>nrep<span class="ot">=</span><span class="fu">table</span>(N[,,<span class="dv">1</span>])</span>
<span id="cb50-5"><a href="#cb50-5" tabindex="-1"></a>nrep<span class="ot">=</span><span class="fu">as.numeric</span>(<span class="fu">names</span>(nrep[<span class="fu">which</span>(<span class="fu">names</span>(nrep) <span class="sc">!=</span><span class="dv">0</span>)]))</span>
<span id="cb50-6"><a href="#cb50-6" tabindex="-1"></a></span>
<span id="cb50-7"><a href="#cb50-7" tabindex="-1"></a><span class="do">##############################</span></span>
<span id="cb50-8"><a href="#cb50-8" tabindex="-1"></a><span class="do">## Expected Mean Square method</span></span>
<span id="cb50-9"><a href="#cb50-9" tabindex="-1"></a><span class="do">##############################</span></span>
<span id="cb50-10"><a href="#cb50-10" tabindex="-1"></a></span>
<span id="cb50-11"><a href="#cb50-11" tabindex="-1"></a>mix1 <span class="ot">&lt;-</span> <span class="fu">lm</span>(yield<span class="sc">~</span> setf <span class="sc">+</span> setf<span class="sc">:</span>repf <span class="sc">+</span> </span>
<span id="cb50-12"><a href="#cb50-12" tabindex="-1"></a>             femalef<span class="sc">:</span>malef<span class="sc">:</span>setf <span class="sc">+</span> malef<span class="sc">:</span>setf <span class="sc">+</span> </span>
<span id="cb50-13"><a href="#cb50-13" tabindex="-1"></a>             femalef<span class="sc">:</span>setf, </span>
<span id="cb50-14"><a href="#cb50-14" tabindex="-1"></a>           <span class="at">data=</span>DT)</span>
<span id="cb50-15"><a href="#cb50-15" tabindex="-1"></a>MS <span class="ot">&lt;-</span> <span class="fu">anova</span>(mix1); MS</span></code></pre></div>
<pre><code>## Analysis of Variance Table
## 
## Response: yield
##                    Df  Sum Sq Mean Sq F value    Pr(&gt;F)    
## setf                1  847836  847836 45.6296 1.097e-09 ***
## setf:repf           4  144345   36086  1.9421  0.109652    
## setf:malef          8  861053  107632  5.7926 5.032e-06 ***
## setf:femalef        8  527023   65878  3.5455  0.001227 ** 
## setf:femalef:malef 32  807267   25227  1.3577  0.129527    
## Residuals          96 1783762   18581                      
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" tabindex="-1"></a>ms1 <span class="ot">&lt;-</span> MS[<span class="st">&quot;setf:malef&quot;</span>,<span class="st">&quot;Mean Sq&quot;</span>]</span>
<span id="cb52-2"><a href="#cb52-2" tabindex="-1"></a>ms2 <span class="ot">&lt;-</span> MS[<span class="st">&quot;setf:femalef&quot;</span>,<span class="st">&quot;Mean Sq&quot;</span>]</span>
<span id="cb52-3"><a href="#cb52-3" tabindex="-1"></a>ms3 <span class="ot">&lt;-</span> MS[<span class="st">&quot;setf:femalef:malef&quot;</span>,<span class="st">&quot;Mean Sq&quot;</span>]</span>
<span id="cb52-4"><a href="#cb52-4" tabindex="-1"></a>mse <span class="ot">&lt;-</span> MS[<span class="st">&quot;Residuals&quot;</span>,<span class="st">&quot;Mean Sq&quot;</span>]</span>
<span id="cb52-5"><a href="#cb52-5" tabindex="-1"></a>nrep<span class="ot">=</span><span class="fu">length</span>(<span class="fu">unique</span>(DT<span class="sc">$</span>rep))</span>
<span id="cb52-6"><a href="#cb52-6" tabindex="-1"></a>nfem<span class="ot">=</span><span class="fu">length</span>(<span class="fu">unique</span>(DT<span class="sc">$</span>female))</span>
<span id="cb52-7"><a href="#cb52-7" tabindex="-1"></a>nmal<span class="ot">=</span><span class="fu">length</span>(<span class="fu">unique</span>(DT<span class="sc">$</span>male))</span>
<span id="cb52-8"><a href="#cb52-8" tabindex="-1"></a>Vfm <span class="ot">&lt;-</span> (ms3<span class="sc">-</span>mse)<span class="sc">/</span>nrep; </span>
<span id="cb52-9"><a href="#cb52-9" tabindex="-1"></a>Vf <span class="ot">&lt;-</span> (ms2<span class="sc">-</span>ms3)<span class="sc">/</span>(nrep<span class="sc">*</span>nmale); </span>
<span id="cb52-10"><a href="#cb52-10" tabindex="-1"></a>Vm <span class="ot">&lt;-</span> (ms1<span class="sc">-</span>ms3)<span class="sc">/</span>(nrep<span class="sc">*</span>nfemale); </span>
<span id="cb52-11"><a href="#cb52-11" tabindex="-1"></a></span>
<span id="cb52-12"><a href="#cb52-12" tabindex="-1"></a>Va<span class="ot">=</span><span class="dv">4</span><span class="sc">*</span>Vm; <span class="co"># assuming no inbreeding (4/(1+F))</span></span>
<span id="cb52-13"><a href="#cb52-13" tabindex="-1"></a>Va<span class="ot">=</span><span class="dv">4</span><span class="sc">*</span>Vf; <span class="co"># assuming no inbreeding (4/(1+F))</span></span>
<span id="cb52-14"><a href="#cb52-14" tabindex="-1"></a>Vd<span class="ot">=</span><span class="dv">4</span><span class="sc">*</span>(Vfm); <span class="co"># assuming no inbreeding(4/(1+F)^2)</span></span>
<span id="cb52-15"><a href="#cb52-15" tabindex="-1"></a>Vg<span class="ot">=</span><span class="fu">c</span>(Va,Vd); <span class="fu">names</span>(Vg) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;Va&quot;</span>,<span class="st">&quot;Vd&quot;</span>); Vg</span></code></pre></div>
<pre><code>##        Va        Vd 
## 10840.192  8861.659</code></pre>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" tabindex="-1"></a><span class="do">##############################</span></span>
<span id="cb54-2"><a href="#cb54-2" tabindex="-1"></a><span class="do">## REML method</span></span>
<span id="cb54-3"><a href="#cb54-3" tabindex="-1"></a><span class="do">##############################</span></span>
<span id="cb54-4"><a href="#cb54-4" tabindex="-1"></a></span>
<span id="cb54-5"><a href="#cb54-5" tabindex="-1"></a>mix2 <span class="ot">&lt;-</span> <span class="fu">lmebreed</span>(yield<span class="sc">~</span> setf <span class="sc">+</span> setf<span class="sc">:</span>repf <span class="sc">+</span></span>
<span id="cb54-6"><a href="#cb54-6" tabindex="-1"></a>               (<span class="dv">1</span><span class="sc">|</span>femalef<span class="sc">:</span>malef<span class="sc">:</span>setf) <span class="sc">+</span> (<span class="dv">1</span><span class="sc">|</span>malef<span class="sc">:</span>setf) <span class="sc">+</span> </span>
<span id="cb54-7"><a href="#cb54-7" tabindex="-1"></a>               (<span class="dv">1</span><span class="sc">|</span>femalef<span class="sc">:</span>setf),</span>
<span id="cb54-8"><a href="#cb54-8" tabindex="-1"></a>             <span class="at">verbose =</span> <span class="cn">FALSE</span>, <span class="at">data=</span>DT)</span>
<span id="cb54-9"><a href="#cb54-9" tabindex="-1"></a>vc <span class="ot">&lt;-</span> <span class="fu">VarCorr</span>(mix2); <span class="fu">print</span>(vc,<span class="at">comp=</span><span class="fu">c</span>(<span class="st">&quot;Variance&quot;</span>))</span></code></pre></div>
<pre><code>##  Groups             Name        Variance
##  femalef:malef:setf (Intercept)  2215.4 
##  malef:setf         (Intercept)  5493.6 
##  femalef:setf       (Intercept)  2710.0 
##  Residual                       18580.9</code></pre>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" tabindex="-1"></a>Vfm <span class="ot">&lt;-</span> vc<span class="sc">$</span><span class="st">`</span><span class="at">femalef:malef:setf</span><span class="st">`</span></span>
<span id="cb56-2"><a href="#cb56-2" tabindex="-1"></a>Vm <span class="ot">&lt;-</span> vc<span class="sc">$</span><span class="st">`</span><span class="at">malef:setf</span><span class="st">`</span></span>
<span id="cb56-3"><a href="#cb56-3" tabindex="-1"></a>Vf <span class="ot">&lt;-</span> vc<span class="sc">$</span><span class="st">`</span><span class="at">femalef:setf</span><span class="st">`</span></span>
<span id="cb56-4"><a href="#cb56-4" tabindex="-1"></a></span>
<span id="cb56-5"><a href="#cb56-5" tabindex="-1"></a>Va<span class="ot">=</span><span class="dv">4</span><span class="sc">*</span>Vm; <span class="co"># assuming no inbreeding (4/(1+F))</span></span>
<span id="cb56-6"><a href="#cb56-6" tabindex="-1"></a>Va<span class="ot">=</span><span class="dv">4</span><span class="sc">*</span>Vf; <span class="co"># assuming no inbreeding (4/(1+F))</span></span>
<span id="cb56-7"><a href="#cb56-7" tabindex="-1"></a>Vd<span class="ot">=</span><span class="dv">4</span><span class="sc">*</span>(Vfm); <span class="co"># assuming no inbreeding(4/(1+F)^2)</span></span>
<span id="cb56-8"><a href="#cb56-8" tabindex="-1"></a>Vg<span class="ot">=</span><span class="fu">c</span>(Va,Vd); <span class="fu">names</span>(Vg) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;Va&quot;</span>,<span class="st">&quot;Vd&quot;</span>); Vg</span></code></pre></div>
<pre><code>##        Va        Vd 
## 10840.199  8861.682</code></pre>
<p>As can be seen, the REML method is easier than manipulating the MS
and we arrive to the same results.</p>
</div>
</div>
<div id="gwas-by-gblup" class="section level3">
<h3>4) GWAS by GBLUP</h3>
<p>Gualdron-Duarte et al. (2014) and Bernal-Rubio et al. (2016) proved
that in (SingleStep)GBLUP or RRBLUP/SNP-BLUP, dividing the estimate of
the marker effect by its standard error is mathematically equivalent to
fixed regression EMMAX GWAS, even if markers are estimated as random
effects in GBLUP and as fixed effects in EMMAX. That way fitting a GBLUP
model is enough to perform GWAS for additive and on-additive
effects.</p>
<p>Let us use the DT_cpdata dataset to explore the GWAS by GBLUP
method</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" tabindex="-1"></a><span class="fu">data</span>(DT_cpdata)</span>
<span id="cb58-2"><a href="#cb58-2" tabindex="-1"></a>DT <span class="ot">&lt;-</span> DT_cpdata</span>
<span id="cb58-3"><a href="#cb58-3" tabindex="-1"></a>GT <span class="ot">&lt;-</span> GT_cpdata<span class="co">#[,1:200]</span></span>
<span id="cb58-4"><a href="#cb58-4" tabindex="-1"></a>MP <span class="ot">&lt;-</span> MP_cpdata</span>
<span id="cb58-5"><a href="#cb58-5" tabindex="-1"></a>M<span class="ot">&lt;-</span> GT</span>
<span id="cb58-6"><a href="#cb58-6" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(DT) <span class="co"># to be used for degrees of freedom</span></span>
<span id="cb58-7"><a href="#cb58-7" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="co"># to be used for degrees of freedom (number of levels in fixed effects)</span></span></code></pre></div>
<p>Instead of fitting the RRBLUP/SNP-BLUP model we can fit a GBLUP model
which is less computationally demanding and recover marker effects and
their standard errors from the genotype effects.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" tabindex="-1"></a><span class="co"># ###########################</span></span>
<span id="cb59-2"><a href="#cb59-2" tabindex="-1"></a><span class="co"># #### GWAS by GBLUP approach</span></span>
<span id="cb59-3"><a href="#cb59-3" tabindex="-1"></a><span class="co"># ###########################</span></span>
<span id="cb59-4"><a href="#cb59-4" tabindex="-1"></a><span class="co"># MMT &lt;-tcrossprod(M) ## MM&#39; = additive relationship matrix </span></span>
<span id="cb59-5"><a href="#cb59-5" tabindex="-1"></a><span class="co"># MMT &lt;- MMT + diag(1e-4, ncol(MMT), ncol(MMT) )</span></span>
<span id="cb59-6"><a href="#cb59-6" tabindex="-1"></a><span class="co"># MMTinv&lt;-solve( MMT ) ## inverse</span></span>
<span id="cb59-7"><a href="#cb59-7" tabindex="-1"></a><span class="co"># MTMMTinv&lt;-t(M)%*%MMTinv # M&#39; %*% (M&#39;M)-</span></span>
<span id="cb59-8"><a href="#cb59-8" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb59-9"><a href="#cb59-9" tabindex="-1"></a><span class="co"># mix.part &lt;- lmebreed(color ~ (1|id) + (1|Rowf) + (1|Colf),</span></span>
<span id="cb59-10"><a href="#cb59-10" tabindex="-1"></a><span class="co">#                      relmat = list(id=MMT),</span></span>
<span id="cb59-11"><a href="#cb59-11" tabindex="-1"></a><span class="co">#                      control = lmerControl(</span></span>
<span id="cb59-12"><a href="#cb59-12" tabindex="-1"></a><span class="co">#                        check.nobs.vs.nlev = &quot;ignore&quot;,</span></span>
<span id="cb59-13"><a href="#cb59-13" tabindex="-1"></a><span class="co">#                        check.nobs.vs.rankZ = &quot;ignore&quot;,</span></span>
<span id="cb59-14"><a href="#cb59-14" tabindex="-1"></a><span class="co">#                        check.nobs.vs.nRE=&quot;ignore&quot;</span></span>
<span id="cb59-15"><a href="#cb59-15" tabindex="-1"></a><span class="co">#                      ), verbose = FALSE,</span></span>
<span id="cb59-16"><a href="#cb59-16" tabindex="-1"></a><span class="co">#                      data=DT)</span></span>
<span id="cb59-17"><a href="#cb59-17" tabindex="-1"></a><span class="co"># vc &lt;- VarCorr(mix.part); print(vc,comp=c(&quot;Variance&quot;))</span></span>
<span id="cb59-18"><a href="#cb59-18" tabindex="-1"></a><span class="co"># mme &lt;- getMME(object=mix.part)</span></span>
<span id="cb59-19"><a href="#cb59-19" tabindex="-1"></a><span class="co"># #convert BLUPs to marker effects me=M&#39;(M&#39;M)- u</span></span>
<span id="cb59-20"><a href="#cb59-20" tabindex="-1"></a><span class="co"># re &lt;- ranef(mix.part)$id</span></span>
<span id="cb59-21"><a href="#cb59-21" tabindex="-1"></a><span class="co"># a.from.g&lt;-MTMMTinv[,rownames(re)]%*%matrix(re[,1],ncol=1)</span></span>
<span id="cb59-22"><a href="#cb59-22" tabindex="-1"></a><span class="co"># var.g &lt;- kronecker(MMT[rownames(re),rownames(re)],vc$id) - </span></span>
<span id="cb59-23"><a href="#cb59-23" tabindex="-1"></a><span class="co">#   mme$Ci[rownames(re),rownames(re) ]</span></span>
<span id="cb59-24"><a href="#cb59-24" tabindex="-1"></a><span class="co"># var.a.from.g &lt;- t(M)%*%MMTinv[,rownames(re)]%*% (var.g) %*% t(MMTinv[,rownames(re)])%*%M</span></span>
<span id="cb59-25"><a href="#cb59-25" tabindex="-1"></a><span class="co"># se.a.from.g &lt;- sqrt(diag(var.a.from.g))</span></span>
<span id="cb59-26"><a href="#cb59-26" tabindex="-1"></a><span class="co"># t.stat.from.g &lt;- a.from.g/se.a.from.g # t-statistic</span></span>
<span id="cb59-27"><a href="#cb59-27" tabindex="-1"></a><span class="co"># pvalGBLUP &lt;- dt(t.stat.from.g,df=n-k-1) # -log10(pval)</span></span></code></pre></div>
<p>Now we can look at the p-values coming from the 3 approaches to
indeed show that results are equivalent.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a><span class="co"># plot(-log(pvalGBLUP), main=&quot;GWAS by GBLUP&quot;)</span></span></code></pre></div>
</div>
</div>
<div id="literature" class="section level2">
<h2>Literature</h2>
<p>Giovanny Covarrubias-Pazaran (2024). lme4breeding: enabling genetic
evaluation in the age of genomic data. To be submitted to
Bioinformatics.</p>
<p>Bates Douglas, Maechler Martin, Bolker Ben, Walker Steve. 2015.
Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical
Software, 67(1), 1-48.</p>
<p>Bernardo Rex. 2010. Breeding for quantitative traits in plants.
Second edition. Stemma Press. 390 pp.</p>
<p>Gilmour et al. 1995. Average Information REML: An efficient algorithm
for variance parameter estimation in linear mixed models. Biometrics
51(4):1440-1450.</p>
<p>Henderson C.R. 1975. Best Linear Unbiased Estimation and Prediction
under a Selection Model. Biometrics vol. 31(2):423-447.</p>
<p>Kang et al. 2008. Efficient control of population structure in model
organism association mapping. Genetics 178:1709-1723.</p>
<p>Lee, D.-J., Durban, M., and Eilers, P.H.C. (2013). Efficient
two-dimensional smoothing with P-spline ANOVA mixed models and nested
bases. Computational Statistics and Data Analysis, 61, 22 - 37.</p>
<p>Lee et al. 2015. MTG2: An efficient algorithm for multivariate linear
mixed model analysis based on genomic information. Cold Spring Harbor.
doi: <a href="http://dx.doi.org/10.1101/027201" class="uri">http://dx.doi.org/10.1101/027201</a>.</p>
<p>Maier et al. 2015. Joint analysis of psychiatric disorders increases
accuracy of risk prediction for schizophrenia, bipolar disorder, and
major depressive disorder. Am J Hum Genet; 96(2):283-294.</p>
<p>Rodriguez-Alvarez, Maria Xose, et al. Correcting for spatial
heterogeneity in plant breeding experiments with P-splines. Spatial
Statistics 23 (2018): 52-71.</p>
<p>Searle. 1993. Applying the EM algorithm to calculating ML and REML
estimates of variance components. Paper invited for the 1993 American
Statistical Association Meeting, San Francisco.</p>
<p>Yu et al. 2006. A unified mixed-model method for association mapping
that accounts for multiple levels of relatedness. Genetics
38:203-208.</p>
<p>Tunnicliffe W. 1989. On the use of marginal likelihood in time series
model estimation. JRSS 51(1):15-27.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
